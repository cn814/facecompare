<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Comparison Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        :root {
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --bg-primary: white;
            --text-primary: #333;
            --text-secondary: #666;
            --text-tertiary: #999;
            --border-color: #e0e0e0;
            --upload-border: #667eea;
            --upload-bg: #f8f9ff;
            --upload-bg-hover: #f0f2ff;
            --result-bg: #f8f9fa;
            --info-bg: #e3f2fd;
            --info-border: #2196f3;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        body.dark-mode {
            --bg-gradient-start: #1a1a2e;
            --bg-gradient-end: #16213e;
            --bg-primary: #2d2d44;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --text-tertiary: #808080;
            --border-color: #404050;
            --upload-border: #667eea;
            --upload-bg: #353545;
            --upload-bg-hover: #3d3d4d;
            --result-bg: #353545;
            --info-bg: #2a3f5f;
            --info-border: #4a9eff;
            --shadow-color: rgba(0, 0, 0, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
        }

        .icon-btn {
            background: var(--bg-primary);
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            box-shadow: 0 4px 10px var(--shadow-color);
            transition: all 0.3s;
            color: var(--text-primary);
            font-weight: 600;
        }

        .icon-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px var(--shadow-color);
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .loading {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px var(--shadow-color);
            color: var(--text-primary);
        }

        .loading-bar {
            width: 100%;
            height: 8px;
            background: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
        }

        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .upload-box {
            background: var(--bg-primary);
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 10px 30px var(--shadow-color);
        }

        .upload-box h2 {
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .upload-box p {
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .upload-area {
            border: 3px dashed var(--upload-border);
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: var(--upload-bg);
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: var(--upload-bg-hover);
        }

        .upload-area.has-image {
            border-style: solid;
            border-color: #4caf50;
            padding: 10px;
        }

        input[type="file"] {
            display: none;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .preview-container {
            position: relative;
            max-width: 100%;
        }

        .preview-image,
        .preview-container canvas {
            max-width: 100%;
            max-height: 400px;
            height: auto;
            border-radius: 5px;
            display: block;
            margin: 0 auto;
        }

        .face-box {
            position: absolute;
            border: 4px solid #4caf50;
            border-radius: 5px;
            box-sizing: border-box;
            cursor: pointer;
            transition: all 0.2s;
        }

        .face-box:hover {
            border-color: #45a049;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .face-box.selected {
            border-color: #ffc107;
            border-width: 5px;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.7);
        }

        .face-label {
            position: absolute;
            background: #4caf50;
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
        }

        .quality-badge {
            position: absolute;
            background: rgba(33, 150, 243, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
        }

        .age-badge {
            position: absolute;
            background: rgba(156, 39, 176, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
        }

        .compare-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .compare-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(102, 126, 234, 0.6);
        }

        .compare-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Ensure buttons work well in dark mode */
        body.dark-mode .compare-btn {
            color: white;
        }

        .age-toggle {
            margin-top: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: var(--text-secondary);
        }

        .age-toggle input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .results {
            background: var(--bg-primary);
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 10px 30px var(--shadow-color);
            margin-top: 20px;
        }

        .results h2 {
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        .result-item {
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 8px;
            background: var(--result-bg);
            border-left: 5px solid #667eea;
        }

        .result-item h3, .result-item h4 {
            color: var(--text-primary);
        }

        .result-item p {
            color: var(--text-secondary);
        }

        .result-item.match {
            background: #e8f5e9;
            border-left-color: #4caf50;
        }

        body.dark-mode .result-item.match {
            background: #1b3d1f;
        }

        .result-item.no-match {
            background: #ffebee;
            border-left-color: #f44336;
        }

        body.dark-mode .result-item.no-match {
            background: #3d1f1f;
        }

        .similarity-score {
            font-size: 2em;
            font-weight: bold;
            margin: 15px 0;
        }

        .similarity-score.match {
            color: #4caf50;
        }

        .similarity-score.no-match {
            color: #f44336;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: var(--border-color);
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            transition: width 0.5s ease;
        }

        .progress-fill.match {
            background: linear-gradient(90deg, #4caf50, #66bb6a);
        }

        .progress-fill.no-match {
            background: linear-gradient(90deg, #f44336, #ef5350);
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #f44336;
        }

        body.dark-mode .error {
            background: #3d1f1f;
            color: #ff6b6b;
        }

        .info {
            background: var(--info-bg);
            border-left: 4px solid var(--info-border);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        @media (max-width: 768px) {
            .upload-section {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2em;
            }
        }

        .hidden {
            display: none;
        }

        .reference-selector {
            margin: 15px 0;
            padding: 15px;
            background: var(--info-bg);
            border-radius: 8px;
            border-left: 4px solid var(--info-border);
        }

        .reference-selector p {
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .face-thumbnails {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .face-thumbnail {
            width: 80px;
            height: 80px;
            border: 3px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            object-fit: cover;
        }

        .face-thumbnail:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }

        .face-thumbnail.selected {
            border-color: #ffc107;
            border-width: 4px;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }

        .comparison-canvas-container {
            position: relative;
            display: inline-block;
        }

        .color-legend {
            background: var(--result-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .color-legend h3 {
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .color-legend div {
            color: var(--text-secondary);
            display: flex;
            align-items: flex-start;
            margin: 5px 0;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-controls">
            <div></div>
            <div class="control-buttons">
                <button class="icon-btn" onclick="clearAll()" title="Clear all images and results">
                    üîÑ Reset
                </button>
                <button class="icon-btn" onclick="toggleDarkMode()" title="Toggle dark mode">
                    üåì Theme
                </button>
            </div>
        </div>

        <h1>üîç Face Comparison Tool</h1>
        <p class="subtitle">Upload photos to compare faces using advanced AI recognition</p>
        
        <div id="loading" class="loading hidden">
            <p>Loading AI models...</p>
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
            <p id="loadingStatus" style="margin-top: 10px; font-size: 0.9em; color: var(--text-secondary);"></p>
        </div>

        <div class="upload-section">
            <div class="upload-box">
                <h2>üì∏ Reference Photo</h2>
                <p>Upload the face you want to use as reference</p>
                <div class="upload-area" id="referenceUpload" onclick="document.getElementById('referenceInput').click()">
                    <div class="upload-icon">üìÅ</div>
                    <p>Click to upload or drag and drop</p>
                    <small style="color: var(--text-tertiary);">Supports: JPG, PNG, WebP</small>
                </div>
                <input type="file" id="referenceInput" accept="image/*" onchange="handleReferenceUpload(event)">
                
                <div id="referenceFaceSelector" class="reference-selector hidden">
                    <p><strong>Multiple faces detected!</strong> Click on a face above or select below:</p>
                    <div id="faceThumbnails" class="face-thumbnails"></div>
                </div>
            </div>

            <div class="upload-box">
                <h2>üñºÔ∏è Comparison Photos</h2>
                <p>Upload one or more photos to compare against the reference</p>
                <div class="upload-area" id="comparisonUpload" onclick="document.getElementById('comparisonInput').click()">
                    <div class="upload-icon">üìÅ</div>
                    <p>Click to upload or drag and drop</p>
                    <small style="color: var(--text-tertiary);">Supports multiple files</small>
                </div>
                <input type="file" id="comparisonInput" accept="image/*" multiple onchange="handleComparisonUpload(event)">
                <div id="comparisonPreviews" style="margin-top: 20px;"></div>
            </div>
        </div>

        <div class="age-toggle">
            <input type="checkbox" id="ageEstimationToggle">
            <label for="ageEstimationToggle"><strong>Enable Age Estimation</strong> (may increase processing time)</label>
        </div>

        <button class="compare-btn" id="compareBtn" onclick="compareFaces()" disabled>
            üîç Compare Faces
        </button>

        <div id="results" class="results hidden">
            <h2>üìä Comparison Results</h2>
        </div>
    </div>

    <script>
        let modelsLoaded = false;
        let referenceImage = null;
        let referenceFaces = [];
        let selectedReferenceIndex = 0;
        let comparisonImages = [];
        let comparisonResults = [];

        async function loadModels() {
            const loadingDiv = document.getElementById('loading');
            const progressBar = document.getElementById('loadingProgress');
            const statusText = document.getElementById('loadingStatus');
            
            loadingDiv.classList.remove('hidden');
            
            try {
                const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
                
                // Load face detection models
                statusText.textContent = 'Loading face detection models...';
                progressBar.style.width = '20%';
                await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
                
                progressBar.style.width = '40%';
                await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL);
                
                // Load face recognition model
                statusText.textContent = 'Loading face recognition model...';
                progressBar.style.width = '60%';
                await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
                
                progressBar.style.width = '80%';
                await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);
                
                // Load age estimation model
                statusText.textContent = 'Loading age estimation model...';
                progressBar.style.width = '90%';
                await faceapi.nets.ageGenderNet.loadFromUri(MODEL_URL);
                
                progressBar.style.width = '100%';
                statusText.textContent = 'All models loaded successfully!';
                
                setTimeout(() => {
                    loadingDiv.classList.add('hidden');
                    modelsLoaded = true;
                }, 500);
                
                console.log('All models loaded successfully');
            } catch (error) {
                console.error('Error loading models:', error);
                statusText.textContent = 'Error loading models. Please refresh the page.';
                statusText.style.color = '#f44336';
            }
        }

        function setupEventListeners() {
            // Drag and drop for reference
            const referenceUpload = document.getElementById('referenceUpload');
            referenceUpload.addEventListener('dragover', (e) => {
                e.preventDefault();
                referenceUpload.style.borderColor = '#764ba2';
            });
            
            referenceUpload.addEventListener('dragleave', () => {
                referenceUpload.style.borderColor = '';
            });
            
            referenceUpload.addEventListener('drop', (e) => {
                e.preventDefault();
                referenceUpload.style.borderColor = '';
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    handleReferenceUpload({ target: { files: [file] } });
                }
            });

            // Drag and drop for comparison
            const comparisonUpload = document.getElementById('comparisonUpload');
            comparisonUpload.addEventListener('dragover', (e) => {
                e.preventDefault();
                comparisonUpload.style.borderColor = '#764ba2';
            });
            
            comparisonUpload.addEventListener('dragleave', () => {
                comparisonUpload.style.borderColor = '';
            });
            
            comparisonUpload.addEventListener('drop', (e) => {
                e.preventDefault();
                comparisonUpload.style.borderColor = '';
                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                if (files.length > 0) {
                    handleComparisonUpload({ target: { files } });
                }
            });
        }

        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all images and results?')) {
                // Reset all data
                referenceImage = null;
                referenceFaces = [];
                selectedReferenceIndex = 0;
                comparisonImages = [];
                comparisonResults = [];
                
                // Reset UI elements
                const referenceUpload = document.getElementById('referenceUpload');
                referenceUpload.classList.remove('has-image');
                referenceUpload.innerHTML = `
                    <div class="upload-icon">üìÅ</div>
                    <p>Click to upload or drag and drop</p>
                    <small style="color: var(--text-tertiary);">Supports: JPG, PNG, WebP</small>
                `;
                
                const comparisonUpload = document.getElementById('comparisonUpload');
                comparisonUpload.classList.remove('has-image');
                comparisonUpload.innerHTML = `
                    <div class="upload-icon">üìÅ</div>
                    <p>Click to upload or drag and drop</p>
                    <small style="color: var(--text-tertiary);">Supports multiple files</small>
                `;
                
                document.getElementById('comparisonPreviews').innerHTML = '';
                document.getElementById('referenceFaceSelector').classList.add('hidden');
                document.getElementById('results').classList.add('hidden');
                document.getElementById('compareBtn').disabled = true;
                
                // Reset file inputs
                document.getElementById('referenceInput').value = '';
                document.getElementById('comparisonInput').value = '';
            }
        }

        function calculateFaceQuality(detection) {
            let qualityScore = 0;
            let factors = [];
            
            // Factor 1: Detection confidence (0-30 points)
            const confidence = detection.detection.score;
            const confidencePoints = confidence * 30;
            qualityScore += confidencePoints;
            factors.push(`Confidence: ${(confidence * 100).toFixed(1)}%`);
            
            // Factor 2: Face size (0-30 points)
            const faceBox = detection.detection.box;
            const faceArea = faceBox.width * faceBox.height;
            const imageDimension = faceBox.width; // Approximate
            const sizeRatio = Math.sqrt(faceArea) / imageDimension;
            const sizePoints = Math.min(30, sizeRatio * 60);
            qualityScore += sizePoints;
            factors.push(`Size: ${faceBox.width.toFixed(0)}x${faceBox.height.toFixed(0)}px`);
            
            // Factor 3: Face alignment/angle (0-40 points)
            // Using landmarks to assess alignment
            if (detection.landmarks) {
                const landmarks = detection.landmarks;
                const leftEye = landmarks.getLeftEye();
                const rightEye = landmarks.getRightEye();
                
                // Calculate eye level difference
                const leftEyeY = leftEye.reduce((sum, p) => sum + p.y, 0) / leftEye.length;
                const rightEyeY = rightEye.reduce((sum, p) => sum + p.y, 0) / rightEye.length;
                const eyeLevelDiff = Math.abs(leftEyeY - rightEyeY);
                
                // More level = better quality
                const alignmentPoints = Math.max(0, 40 - (eyeLevelDiff / faceBox.height) * 100);
                qualityScore += alignmentPoints;
                factors.push(`Alignment: ${alignmentPoints > 30 ? 'Good' : alignmentPoints > 20 ? 'Fair' : 'Poor'}`);
            }
            
            // Normalize to 0-100
            qualityScore = Math.min(100, Math.max(0, qualityScore));
            
            return {
                score: qualityScore,
                factors: factors,
                rating: qualityScore >= 80 ? 'Excellent' : 
                       qualityScore >= 60 ? 'Good' : 
                       qualityScore >= 40 ? 'Fair' : 'Poor'
            };
        }

        async function detectFaces(img, enableAge = false) {
            console.log('Starting face detection...');
            let detections = [];
            
            // Strategy 1: TinyFaceDetector with larger input size for small faces
            try {
                console.log('Trying TinyFaceDetector with large input size (608) and threshold 0.3...');
                const tinyLargeOptions = new faceapi.TinyFaceDetectorOptions({ inputSize: 608, scoreThreshold: 0.3 });
                
                if (enableAge) {
                    detections = await faceapi
                        .detectAllFaces(img, tinyLargeOptions)
                        .withFaceLandmarks()
                        .withFaceDescriptors()
                        .withAgeAndGender();
                } else {
                    detections = await faceapi
                        .detectAllFaces(img, tinyLargeOptions)
                        .withFaceLandmarks()
                        .withFaceDescriptors();
                }
                
                console.log('TinyFaceDetector (large) found', detections.length, 'faces');
                
                if (detections.length > 0) {
                    return detections;
                }
            } catch (error) {
                console.error('TinyFaceDetector (large) failed:', error);
            }
            
            // Strategy 2: TinyFaceDetector with standard input size
            try {
                console.log('Trying TinyFaceDetector with threshold 0.3...');
                const tinyOptions = new faceapi.TinyFaceDetectorOptions({ inputSize: 512, scoreThreshold: 0.3 });
                
                if (enableAge) {
                    detections = await faceapi
                        .detectAllFaces(img, tinyOptions)
                        .withFaceLandmarks()
                        .withFaceDescriptors()
                        .withAgeAndGender();
                } else {
                    detections = await faceapi
                        .detectAllFaces(img, tinyOptions)
                        .withFaceLandmarks()
                        .withFaceDescriptors();
                }
                
                console.log('TinyFaceDetector found', detections.length, 'faces');
                
                if (detections.length > 0) {
                    return detections;
                }
            } catch (error) {
                console.error('TinyFaceDetector failed:', error);
            }
            
            // Strategy 3: SSD MobileNet (more accurate, may catch faces TinyFace missed)
            try {
                console.log('Trying SSD MobileNet detector...');
                const ssdOptions = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.3 });
                
                if (enableAge) {
                    detections = await faceapi
                        .detectAllFaces(img, ssdOptions)
                        .withFaceLandmarks()
                        .withFaceDescriptors()
                        .withAgeAndGender();
                } else {
                    detections = await faceapi
                        .detectAllFaces(img, ssdOptions)
                        .withFaceLandmarks()
                        .withFaceDescriptors();
                }
                
                console.log('SSD MobileNet found', detections.length, 'faces');
                
                if (detections.length > 0) {
                    return detections;
                }
            } catch (error) {
                console.error('SSD MobileNet failed:', error);
            }
            
            // Strategy 4: Even more sensitive TinyFaceDetector
            try {
                console.log('Trying TinyFaceDetector with very low threshold 0.2...');
                const veryTinyOptions = new faceapi.TinyFaceDetectorOptions({ inputSize: 416, scoreThreshold: 0.2 });
                
                if (enableAge) {
                    detections = await faceapi
                        .detectAllFaces(img, veryTinyOptions)
                        .withFaceLandmarks()
                        .withFaceDescriptors()
                        .withAgeAndGender();
                } else {
                    detections = await faceapi
                        .detectAllFaces(img, veryTinyOptions)
                        .withFaceLandmarks()
                        .withFaceDescriptors();
                }
                
                console.log('Very sensitive TinyFaceDetector found', detections.length, 'faces');
                
                if (detections.length > 0) {
                    return detections;
                }
            } catch (error) {
                console.error('Very sensitive TinyFaceDetector failed:', error);
            }
            
            // Strategy 5: Ultra-sensitive last attempt
            try {
                console.log('Trying ultra-sensitive TinyFaceDetector with threshold 0.15...');
                const ultraTinyOptions = new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.15 });
                
                if (enableAge) {
                    detections = await faceapi
                        .detectAllFaces(img, ultraTinyOptions)
                        .withFaceLandmarks()
                        .withFaceDescriptors()
                        .withAgeAndGender();
                } else {
                    detections = await faceapi
                        .detectAllFaces(img, ultraTinyOptions)
                        .withFaceLandmarks()
                        .withFaceDescriptors();
                }
                
                console.log('Ultra-sensitive TinyFaceDetector found', detections.length, 'faces');
                
                if (detections.length > 0) {
                    return detections;
                }
            } catch (error) {
                console.error('Ultra-sensitive TinyFaceDetector failed:', error);
            }
            
            console.log('No faces detected with any method');
            return detections;
        }

        async function handleReferenceUpload(event) {
            if (!modelsLoaded) {
                alert('Please wait for the AI models to load first.');
                return;
            }

            const file = event.target.files[0];
            if (!file) {
                console.log('No file selected');
                return;
            }

            console.log('Reference upload started:', file.name);
            const uploadArea = document.getElementById('referenceUpload');
            uploadArea.innerHTML = '<p>Processing image...</p>';

            try {
                console.log('Loading image...');
                const img = await loadImage(file);
                console.log('Image loaded, dimensions:', img.width, 'x', img.height);
                referenceImage = img;

                const enableAge = document.getElementById('ageEstimationToggle').checked;
                console.log('Age estimation enabled:', enableAge);
                
                const detections = await detectFaces(img, enableAge);

                if (detections.length === 0) {
                    throw new Error('No faces detected in the reference image. Please try a different photo with a clear, front-facing view of a face.');
                }

                // Calculate quality scores for all detected faces
                detections.forEach(detection => {
                    detection.quality = calculateFaceQuality(detection);
                });

                referenceFaces = detections;
                selectedReferenceIndex = 0;

                displayReferenceImage(img, detections);
                updateCompareButton();

            } catch (error) {
                console.error('Error processing reference image:', error);
                uploadArea.innerHTML = `
                    <div class="upload-icon">üìÅ</div>
                    <p>Click to upload or drag and drop</p>
                    <small style="color: var(--text-tertiary);">Supports: JPG, PNG, WebP</small>
                `;
                showError(uploadArea, error.message || 'An error occurred while processing the image. Please try again.');
            }
        }

        function displayReferenceImage(img, detections) {
            const uploadArea = document.getElementById('referenceUpload');
            uploadArea.classList.add('has-image');
            uploadArea.innerHTML = '';

            const container = document.createElement('div');
            container.className = 'preview-container';

            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            // Draw face boxes and labels
            detections.forEach((detection, index) => {
                const box = detection.detection.box;
                
                // Draw rectangle
                ctx.strokeStyle = index === selectedReferenceIndex ? '#ffc107' : '#4caf50';
                ctx.lineWidth = index === selectedReferenceIndex ? 10 : 8;
                ctx.strokeRect(box.x, box.y, box.width, box.height);
                
                // Face number label
                ctx.fillStyle = index === selectedReferenceIndex ? '#ffc107' : '#4caf50';
                ctx.fillRect(box.x, box.y - 70, 220, 70);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 36px Arial';
                ctx.fillText(`Face ${index + 1}`, box.x + 15, box.y - 24);
                
                // Quality score
                const quality = detection.quality;
                const qColor = quality.score >= 80 ? '#4caf50' : 
                              quality.score >= 60 ? '#ff9800' : '#f44336';
                ctx.fillStyle = qColor;
                ctx.fillRect(box.x, box.y + box.height, 320, 70);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 32px Arial';
                ctx.fillText(`Quality: ${quality.score.toFixed(0)}%`, box.x + 15, box.y + box.height + 48);
                
                // Age estimation
                if (detection.age) {
                    ctx.fillStyle = '#9c27b0';
                    ctx.fillRect(box.x + 330, box.y + box.height, 240, 70);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 32px Arial';
                    ctx.fillText(`Age: ~${Math.round(detection.age)}`, box.x + 345, box.y + box.height + 48);
                }
            });

            container.appendChild(canvas);
            uploadArea.appendChild(container);

            // Show face selector if multiple faces
            if (detections.length > 1) {
                showFaceSelector(img, detections);
            } else {
                document.getElementById('referenceFaceSelector').classList.add('hidden');
            }
        }

        function showFaceSelector(img, detections) {
            const selectorDiv = document.getElementById('referenceFaceSelector');
            const thumbnailsDiv = document.getElementById('faceThumbnails');
            
            selectorDiv.classList.remove('hidden');
            thumbnailsDiv.innerHTML = '';

            detections.forEach((detection, index) => {
                const canvas = document.createElement('canvas');
                const box = detection.detection.box;
                
                // Add some padding around the face
                const padding = 20;
                const sx = Math.max(0, box.x - padding);
                const sy = Math.max(0, box.y - padding);
                const sw = Math.min(img.width - sx, box.width + padding * 2);
                const sh = Math.min(img.height - sy, box.height + padding * 2);
                
                canvas.width = sw;
                canvas.height = sh;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);
                
                canvas.className = 'face-thumbnail';
                if (index === selectedReferenceIndex) {
                    canvas.classList.add('selected');
                }
                
                canvas.onclick = () => selectReferenceFace(index);
                canvas.title = `Face ${index + 1} - Quality: ${detection.quality.score.toFixed(0)}%`;
                
                thumbnailsDiv.appendChild(canvas);
            });
        }

        function selectReferenceFace(index) {
            selectedReferenceIndex = index;
            displayReferenceImage(referenceImage, referenceFaces);
            
            // If comparison has been done, update results with new reference face
            if (comparisonImages.length > 0 && comparisonImages.some(img => img.faces.length > 0)) {
                compareFaces();
            }
        }

        async function handleComparisonUpload(event) {
            if (!modelsLoaded) {
                alert('Please wait for the AI models to load first.');
                return;
            }

            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            const previewsDiv = document.getElementById('comparisonPreviews');
            previewsDiv.innerHTML = '<p>Processing images...</p>';

            try {
                comparisonImages = [];

                for (const file of files) {
                    const img = await loadImage(file);
                    
                    const enableAge = document.getElementById('ageEstimationToggle').checked;
                    const detections = await detectFaces(img, enableAge);

                    // Calculate quality scores
                    detections.forEach(detection => {
                        detection.quality = calculateFaceQuality(detection);
                    });

                    comparisonImages.push({
                        file: file,
                        image: img,
                        faces: detections.map(d => ({
                            descriptor: d.descriptor,
                            box: d.detection.box,
                            score: d.detection.score,
                            quality: d.quality,
                            age: d.age,
                            gender: d.gender
                        }))
                    });
                }

                displayComparisonImages();
                updateCompareButton();

            } catch (error) {
                console.error('Error processing comparison images:', error);
                previewsDiv.innerHTML = '';
                showError(previewsDiv, error.message || 'Error processing some images. Please try again with different files.');
            }
        }

        function displayComparisonImages(results = null) {
            const previewsDiv = document.getElementById('comparisonPreviews');
            previewsDiv.innerHTML = '';

            comparisonImages.forEach((imgData, imgIndex) => {
                const container = document.createElement('div');
                container.style.marginBottom = '20px';

                const title = document.createElement('h4');
                const faceCountText = imgData.faces.length === 0 ? 
                    '‚ö†Ô∏è 0 faces - may be too small/distant' : 
                    `${imgData.faces.length} face${imgData.faces.length !== 1 ? 's' : ''}`;
                title.textContent = `${imgData.file.name} (${faceCountText})`;
                title.style.color = imgData.faces.length === 0 ? '#f44336' : 'var(--text-primary)';
                title.style.marginBottom = '10px';
                container.appendChild(title);

                const canvasContainer = document.createElement('div');
                canvasContainer.className = 'preview-container comparison-canvas-container';

                const canvas = document.createElement('canvas');
                canvas.width = imgData.image.width;
                canvas.height = imgData.image.height;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(imgData.image, 0, 0);

                // Draw face boxes or "no faces" message
                if (imgData.faces.length === 0) {
                    // Draw a warning overlay when no faces detected
                    ctx.fillStyle = 'rgba(244, 67, 54, 0.8)';
                    ctx.fillRect(10, 10, canvas.width - 20, 160);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 40px Arial';
                    ctx.fillText('‚ö†Ô∏è No faces detected in this image', 50, 80);
                    ctx.font = 'bold 30px Arial';
                    ctx.fillText('Try a photo with larger, clearer faces', 50, 130);
                }
                
                imgData.faces.forEach((face, faceIndex) => {
                    const box = face.box;
                    
                    // Determine box color based on match results
                    let boxColor = '#4caf50'; // Default green
                    let matchPercentage = null;
                    
                    if (results) {
                        // Find the result for this specific face
                        const faceResult = results.find(r => 
                            r.imageIndex === imgIndex && r.faceIndex === faceIndex
                        );
                        
                        if (faceResult) {
                            matchPercentage = faceResult.similarity;
                            // Color code based on similarity
                            if (matchPercentage >= 85) {
                                boxColor = '#4caf50'; // Green - Very likely match
                            } else if (matchPercentage >= 70) {
                                boxColor = '#8bc34a'; // Light green - Likely match
                            } else if (matchPercentage >= 50) {
                                boxColor = '#ffc107'; // Yellow - Possible match
                            } else {
                                boxColor = '#f44336'; // Red - Unlikely match
                            }
                        }
                    }
                    
                    ctx.strokeStyle = boxColor;
                    ctx.lineWidth = 8;
                    ctx.strokeRect(box.x, box.y, box.width, box.height);
                    
                    // Face number
                    ctx.fillStyle = boxColor;
                    ctx.fillRect(box.x, box.y - 70, 220, 70);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 36px Arial';
                    ctx.fillText(`Face ${faceIndex + 1}`, box.x + 15, box.y - 24);
                    
                    // Show match percentage if available
                    if (matchPercentage !== null) {
                        ctx.fillStyle = boxColor;
                        ctx.fillRect(box.x, box.y + box.height, 320, 70);
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 32px Arial';
                        ctx.fillText(`Match: ${matchPercentage.toFixed(1)}%`, box.x + 15, box.y + box.height + 48);
                    } else {
                        // Quality score (when no match results yet)
                        const quality = face.quality;
                        const qColor = quality.score >= 80 ? '#4caf50' : 
                                      quality.score >= 60 ? '#ff9800' : '#f44336';
                        ctx.fillStyle = qColor;
                        ctx.fillRect(box.x, box.y + box.height, 320, 70);
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 32px Arial';
                        ctx.fillText(`Quality: ${quality.score.toFixed(0)}%`, box.x + 15, box.y + box.height + 48);
                    }
                    
                    // Age estimation (only show if no match percentage or alongside it)
                    if (face.age && matchPercentage === null) {
                        ctx.fillStyle = '#9c27b0';
                        ctx.fillRect(box.x + 330, box.y + box.height, 240, 70);
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 32px Arial';
                        ctx.fillText(`Age: ~${Math.round(face.age)}`, box.x + 345, box.y + box.height + 48);
                    } else if (face.age && matchPercentage !== null) {
                        // Show age next to match percentage
                        ctx.fillStyle = '#9c27b0';
                        ctx.fillRect(box.x + 330, box.y + box.height, 240, 70);
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 32px Arial';
                        ctx.fillText(`Age: ~${Math.round(face.age)}`, box.x + 345, box.y + box.height + 48);
                    }
                });

                canvasContainer.appendChild(canvas);
                container.appendChild(canvasContainer);
                previewsDiv.appendChild(container);
            });

            const uploadArea = document.getElementById('comparisonUpload');
            uploadArea.classList.add('has-image');
            uploadArea.style.display = 'none';
        }

        function updateCompareButton() {
            const btn = document.getElementById('compareBtn');
            const hasReferenceFace = referenceFaces.length > 0;
            const hasComparisonImages = comparisonImages.length > 0;
            const hasComparisonFaces = comparisonImages.some(img => img.faces.length > 0);
            
            btn.disabled = !(hasReferenceFace && hasComparisonImages && hasComparisonFaces);
            
            // Update button text with helpful message
            if (hasReferenceFace && hasComparisonImages && !hasComparisonFaces) {
                btn.textContent = '‚ö†Ô∏è No faces detected in comparison photos';
                btn.style.opacity = '0.7';
            } else {
                btn.textContent = 'üîç Compare Faces';
                btn.style.opacity = '';
            }
        }

        function loadImage(file) {
            return new Promise((resolve, reject) => {
                // Validate file
                if (!file) {
                    reject(new Error('No file provided'));
                    return;
                }
                
                if (!file.type || !file.type.startsWith('image/')) {
                    reject(new Error('File must be an image (JPG, PNG, or WebP)'));
                    return;
                }
                
                console.log('Loading image:', file.name, 'Type:', file.type, 'Size:', file.size);
                
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    const img = new Image();
                    
                    img.onload = () => {
                        console.log('Image loaded successfully:', file.name, 'Dimensions:', img.width, 'x', img.height);
                        resolve(img);
                    };
                    
                    img.onerror = (err) => {
                        console.error('Image load error:', err);
                        reject(new Error('Failed to load image. The file may be corrupted or in an unsupported format.'));
                    };
                    
                    img.src = e.target.result;
                };
                
                reader.onerror = (err) => {
                    console.error('FileReader error:', err);
                    reject(new Error('Failed to read the image file. Please try a different file.'));
                };
                
                reader.readAsDataURL(file);
            });
        }

        async function compareFaces() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.classList.remove('hidden');
            resultsDiv.innerHTML = '<h2>üìä Comparison Results</h2><p>Analyzing faces...</p>';

            try {
                const referenceDescriptor = referenceFaces[selectedReferenceIndex].descriptor;
                const referenceQuality = referenceFaces[selectedReferenceIndex].quality;

                resultsDiv.innerHTML = '<h2>üìä Comparison Results</h2>';

                // Reference face info
                const refInfo = document.createElement('div');
                refInfo.className = 'result-item';
                refInfo.style.background = 'var(--info-bg)';
                refInfo.style.borderLeftColor = 'var(--info-border)';
                
                let refAgeInfo = '';
                if (referenceFaces[selectedReferenceIndex].age) {
                    const age = Math.round(referenceFaces[selectedReferenceIndex].age);
                    const gender = referenceFaces[selectedReferenceIndex].gender;
                    refAgeInfo = `<div style="margin-top: 10px; color: var(--text-secondary);">
                        <strong>Estimated Age:</strong> ~${age} years old<br>
                        <strong>Detected Gender:</strong> ${gender}
                    </div>`;
                }
                
                refInfo.innerHTML = `
                    <h3>Reference Face ${referenceFaces.length > 1 ? `${selectedReferenceIndex + 1}` : ''}</h3>
                    <p style="margin-top: 10px; color: var(--text-secondary);">
                        <strong>Quality Score:</strong> ${referenceQuality.score.toFixed(1)}% (${referenceQuality.rating})<br>
                        <strong>Details:</strong> ${referenceQuality.factors.join(', ')}
                    </p>
                    ${refAgeInfo}
                    <button onclick="exportMatchedFace(-1, ${selectedReferenceIndex}, 100)" 
                            class="compare-btn" 
                            style="width: auto; margin-top: 15px; padding: 10px 20px; font-size: 0.9em; background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);">
                        üíæ Download Reference Face
                    </button>
                `;
                resultsDiv.appendChild(refInfo);

                // Color legend
                const colorLegend = document.createElement('div');
                colorLegend.className = 'color-legend';
                colorLegend.innerHTML = `
                    <h3>Match Quality Legend</h3>
                    <div style="display: flex; flex-direction: column; gap: 5px;">
                        <span style="display: inline-block; width: 15px; height: 15px; background: #4caf50; border-radius: 3px; margin-right: 5px; margin-top: 5px;"></span> <strong>Dark Green (‚â•85%):</strong> Very likely match<br>
                        <span style="display: inline-block; width: 15px; height: 15px; background: #8bc34a; border-radius: 3px; margin-right: 5px; margin-top: 5px;"></span> <strong>Light Green (70-84%):</strong> Likely match<br>
                        <span style="display: inline-block; width: 15px; height: 15px; background: #ffc107; border-radius: 3px; margin-right: 5px; margin-top: 5px;"></span> <strong>Yellow (50-69%):</strong> Possible match<br>
                        <span style="display: inline-block; width: 15px; height: 15px; background: #f44336; border-radius: 3px; margin-right: 5px; margin-top: 5px;"></span> <strong>Red (<50%):</strong> Unlikely match
                    </div>
                    <p style="margin-top: 15px; font-style: italic; color: var(--text-secondary);">
                        üì∏ Face boxes in comparison photos are now color-coded to show match likelihood!
                    </p>
                `;
                resultsDiv.appendChild(colorLegend);

                let matchCount = 0;
                let totalFaces = 0;

                // Process all comparisons
                const allComparisons = [];
                comparisonImages.forEach((comp, imgIndex) => {
                    comp.faces.forEach((face, faceIndex) => {
                        totalFaces++;
                        const distance = faceapi.euclideanDistance(referenceDescriptor, face.descriptor);
                        
                        let similarity, confidence, isMatch;
                        if (distance < 0.4) {
                            similarity = 95 + (0.4 - distance) * 12.5;
                            confidence = "Very High";
                            isMatch = true;
                        } else if (distance < 0.5) {
                            similarity = 85 + (0.5 - distance) * 100;
                            confidence = "High";
                            isMatch = true;
                        } else if (distance < 0.6) {
                            similarity = 70 + (0.6 - distance) * 150;
                            confidence = "Good";
                            isMatch = true;
                        } else if (distance < 0.7) {
                            similarity = 50 + (0.7 - distance) * 200;
                            confidence = "Moderate";
                            isMatch = false;
                        } else {
                            similarity = Math.max(0, 50 - (distance - 0.7) * 100);
                            confidence = "Low";
                            isMatch = false;
                        }
                        
                        similarity = Math.min(100, Math.max(0, similarity));
                        if (isMatch) matchCount++;
                        
                        allComparisons.push({
                            fileName: comp.file.name,
                            faceIndex: faceIndex,
                            imageIndex: imgIndex,
                            similarity: similarity,
                            confidence: confidence,
                            isMatch: isMatch,
                            distance: distance,
                            quality: face.quality,
                            age: face.age,
                            gender: face.gender
                        });
                    });
                });

                // Sort by similarity
                allComparisons.sort((a, b) => b.similarity - a.similarity);
                
                // Update comparison images with color-coded results
                displayComparisonImages(allComparisons);

                // Display results
                allComparisons.forEach((comp, index) => {
                    let verdictText, verdictIcon;
                    if (comp.similarity >= 85) {
                        verdictText = "Very likely the same person";
                        verdictIcon = "‚úÖ";
                    } else if (comp.similarity >= 70) {
                        verdictText = "Likely the same person";
                        verdictIcon = "‚úÖ";
                    } else if (comp.similarity >= 50) {
                        verdictText = "Possibly the same person";
                        verdictIcon = "‚ö†Ô∏è";
                    } else {
                        verdictText = "Likely different people";
                        verdictIcon = "‚ùå";
                    }

                    const resultItem = document.createElement('div');
                    resultItem.className = `result-item ${comp.isMatch ? 'match' : 'no-match'}`;

                    let rankBadge = '';
                    if (index === 0 && comp.similarity >= 70) {
                        rankBadge = ' <span style="background: gold; color: #333; padding: 2px 8px; border-radius: 3px; font-size: 0.8em; font-weight: bold;">üèÜ BEST MATCH</span>';
                    }

                    let ageInfo = '';
                    if (comp.age) {
                        ageInfo = `<div style="margin: 10px 0; padding: 10px; background: var(--result-bg); border-radius: 5px;">
                            <strong>üìä Detected Age:</strong> ~${Math.round(comp.age)} years old<br>
                            <strong>Gender:</strong> ${comp.gender}
                        </div>`;
                    }

                    resultItem.innerHTML = `
                        <h4 style="margin-bottom: 10px;">
                            #${index + 1}: ${comp.fileName} - Face ${comp.faceIndex + 1}${rankBadge}
                        </h4>
                        <div class="similarity-score ${comp.isMatch ? 'match' : 'no-match'}">${comp.similarity.toFixed(1)}% Match</div>
                        <div style="margin: 5px 0; color: var(--text-secondary);">Confidence: <strong>${comp.confidence}</strong></div>
                        <div class="progress-bar">
                            <div class="progress-fill ${comp.isMatch ? 'match' : 'no-match'}" style="width: ${comp.similarity}%">
                                ${comp.similarity.toFixed(1)}%
                            </div>
                        </div>
                        <div style="margin: 15px 0; padding: 10px; background: var(--result-bg); border-radius: 5px;">
                            <strong>üéØ Face Quality:</strong> ${comp.quality.score.toFixed(1)}% (${comp.quality.rating})<br>
                            <small style="color: var(--text-tertiary);">${comp.quality.factors.join(' ‚Ä¢ ')}</small>
                        </div>
                        ${ageInfo}
                        <p style="margin-top: 15px; color: var(--text-secondary);">
                            <strong>Verdict:</strong> ${verdictIcon} ${verdictText}
                        </p>
                        <p style="margin-top: 10px; font-size: 0.9em; color: var(--text-tertiary);">
                            Euclidean distance: ${comp.distance.toFixed(3)} (lower = more similar)
                        </p>
                        <button onclick="exportMatchedFace(${comp.imageIndex}, ${comp.faceIndex}, ${comp.similarity})" 
                                class="compare-btn" 
                                style="width: auto; margin-top: 15px; padding: 10px 20px; font-size: 0.9em; background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%);">
                            üíæ Download This Face
                        </button>
                    `;

                    resultsDiv.appendChild(resultItem);
                });

                // Summary
                const summary = document.createElement('div');
                summary.className = 'result-item';
                summary.style.background = 'var(--info-bg)';
                summary.style.borderLeftColor = 'var(--info-border)';
                summary.innerHTML = `
                    <h3>Summary</h3>
                    <p style="font-size: 1.1em; margin-top: 10px;">
                        Found <strong>${matchCount} likely match${matchCount !== 1 ? 'es' : ''}</strong> out of <strong>${totalFaces} face${totalFaces !== 1 ? 's' : ''}</strong> analyzed.
                    </p>
                    <p style="margin-top: 10px; color: var(--text-secondary);">
                        Results are sorted by match percentage (highest first).
                    </p>
                `;
                resultsDiv.appendChild(summary);

                // Export options
                const exportSection = document.createElement('div');
                exportSection.className = 'result-item';
                exportSection.style.background = 'var(--result-bg)';
                exportSection.style.borderLeftColor = '#9c27b0';
                exportSection.innerHTML = `
                    <h3>üì• Export Options</h3>
                    <p style="margin: 15px 0; color: var(--text-secondary);">Download matched faces for further analysis or record-keeping</p>
                    <div style="display: flex; gap: 15px; flex-wrap: wrap; margin-top: 20px;">
                        <button onclick="exportAllTopMatches(70)" class="compare-btn" style="width: auto; padding: 12px 24px; font-size: 1em;" title="Download all faces with 70% or higher match score">
                            üíæ Export Top Matches (‚â•70%)
                        </button>
                        <button onclick="exportAllTopMatches(85)" class="compare-btn" style="width: auto; padding: 12px 24px; font-size: 1em; background: linear-gradient(135deg, #8bc34a 0%, #4caf50 100%);" title="Download only faces with 85% or higher match score">
                            üíæ Export High Matches (‚â•85%)
                        </button>
                        <button onclick="exportComparisonReport()" class="compare-btn" style="width: auto; padding: 12px 24px; font-size: 1em; background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);" title="Generate a visual report showing reference face and top 5 matches side-by-side">
                            üìä Export Visual Report
                        </button>
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background: var(--info-bg); border-radius: 8px; border-left: 3px solid #9c27b0;">
                        <strong>What each option does:</strong><br>
                        <div style="margin-top: 10px; color: var(--text-secondary); line-height: 1.8;">
                            ‚Ä¢ <strong>Top Matches (‚â•70%)</strong>: Downloads all cropped faces that scored 70% or higher<br>
                            ‚Ä¢ <strong>High Matches (‚â•85%)</strong>: Downloads only the best matches (85%+)<br>
                            ‚Ä¢ <strong>Visual Report</strong>: Creates a single image showing reference face + top 5 matches with scores<br>
                            ‚Ä¢ <strong>Individual Download</strong>: Use the purple buttons on each result below to download specific faces
                        </div>
                    </div>
                `;
                resultsDiv.appendChild(exportSection);

                // Info box
                const info = document.createElement('div');
                info.className = 'info';
                info.innerHTML = `
                    <strong>Understanding the results:</strong><br><br>
                    <strong>Match Scores:</strong><br>
                    ‚Ä¢ 85-100% = Very likely the same person<br>
                    ‚Ä¢ 70-84% = Likely the same person<br>
                    ‚Ä¢ 50-69% = Possibly the same person<br>
                    ‚Ä¢ Below 50% = Likely different people<br><br>
                    <strong>Face Quality Scores:</strong><br>
                    ‚Ä¢ Excellent (80-100%): Optimal for comparison<br>
                    ‚Ä¢ Good (60-79%): Reliable for comparison<br>
                    ‚Ä¢ Fair (40-59%): May affect accuracy<br>
                    ‚Ä¢ Poor (<40%): Use caution with results<br><br>
                    <strong>What affects accuracy:</strong><br>
                    ‚Ä¢ Photo angle and lighting<br>
                    ‚Ä¢ Facial expression and age difference<br>
                    ‚Ä¢ Image quality and resolution<br>
                    ‚Ä¢ Accessories (glasses, hats, makeup)<br><br>
                    <strong>Tips for better face detection:</strong><br>
                    ‚Ä¢ Use photos where faces are clearly visible and not too small/distant<br>
                    ‚Ä¢ Front-facing or slightly angled photos work best<br>
                    ‚Ä¢ Ensure good lighting and focus<br>
                    ‚Ä¢ Avoid heavily cropped or low-resolution images<br><br>
                    <strong>üì• Export Features:</strong><br>
                    ‚Ä¢ Download individual matched faces from each result card<br>
                    ‚Ä¢ Export all top matches above a threshold (70% or 85%)<br>
                    ‚Ä¢ Generate a visual comparison report with side-by-side faces<br>
                    ‚Ä¢ All exports are saved as high-quality PNG images<br><br>
                    ${referenceFaces.length > 1 ? '<strong>Tip:</strong> Multiple faces detected in reference photo. Select different faces to compare!' : ''}
                `;
                resultsDiv.appendChild(info);

                resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            } catch (error) {
                console.error('Error comparing faces:', error);
                resultsDiv.innerHTML = '<h2>üìä Comparison Results</h2>';
                showError(resultsDiv, error.message || 'Error during comparison. Please try uploading the images again.');
            }
        }

        function cropFaceFromImage(image, box, padding = 20) {
            // Create a canvas for the cropped face
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Add padding around the face
            const x = Math.max(0, box.x - padding);
            const y = Math.max(0, box.y - padding);
            const width = Math.min(image.width - x, box.width + padding * 2);
            const height = Math.min(image.height - y, box.height + padding * 2);
            
            canvas.width = width;
            canvas.height = height;
            
            ctx.drawImage(image, x, y, width, height, 0, 0, width, height);
            
            return canvas;
        }

        function downloadCanvas(canvas, filename) {
            try {
                // Convert canvas to data URL (avoids CSP blob URL restrictions)
                const dataUrl = canvas.toDataURL('image/png');
                
                // Create download link
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = filename;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } catch (error) {
                console.error('Download error:', error);
                alert('Download failed. Please try again or use a different browser.');
            }
        }

        function exportMatchedFace(imageIndex, faceIndex, similarity) {
            // Handle reference face export
            if (imageIndex === -1) {
                const refFace = referenceFaces[faceIndex];
                const canvas = cropFaceFromImage(referenceImage, refFace.detection.box);
                const filename = `reference_face${referenceFaces.length > 1 ? `_${faceIndex + 1}` : ''}.png`;
                downloadCanvas(canvas, filename);
                return;
            }
            
            const imgData = comparisonImages[imageIndex];
            const face = imgData.faces[faceIndex];
            
            // Crop the face
            const canvas = cropFaceFromImage(imgData.image, face.box);
            
            // Download with descriptive filename
            const filename = `match_${similarity.toFixed(0)}pct_${imgData.file.name.replace(/\.[^/.]+$/, '')}_face${faceIndex + 1}.png`;
            downloadCanvas(canvas, filename);
        }

        function exportAllTopMatches(threshold = 70) {
            const resultsDiv = document.getElementById('results');
            
            if (!resultsDiv || resultsDiv.classList.contains('hidden')) {
                alert('Please run a comparison first!');
                return;
            }
            
            // Find all matches above threshold
            const topMatches = [];
            comparisonImages.forEach((comp, imgIndex) => {
                comp.faces.forEach((face, faceIndex) => {
                    const referenceDescriptor = referenceFaces[selectedReferenceIndex].descriptor;
                    const distance = faceapi.euclideanDistance(referenceDescriptor, face.descriptor);
                    
                    let similarity;
                    if (distance < 0.4) {
                        similarity = 95 + (0.4 - distance) * 12.5;
                    } else if (distance < 0.5) {
                        similarity = 85 + (0.5 - distance) * 100;
                    } else if (distance < 0.6) {
                        similarity = 70 + (0.6 - distance) * 150;
                    } else if (distance < 0.7) {
                        similarity = 50 + (0.7 - distance) * 200;
                    } else {
                        similarity = Math.max(0, 50 - (distance - 0.7) * 100);
                    }
                    similarity = Math.min(100, Math.max(0, similarity));
                    
                    if (similarity >= threshold) {
                        topMatches.push({ imgIndex, faceIndex, similarity, comp });
                    }
                });
            });
            
            if (topMatches.length === 0) {
                alert(`No matches found above ${threshold}% threshold.`);
                return;
            }
            
            // Export each match with a small delay to avoid browser blocking
            topMatches.forEach((match, index) => {
                setTimeout(() => {
                    exportMatchedFace(match.imgIndex, match.faceIndex, match.similarity);
                }, index * 200);
            });
            
            alert(`Exporting ${topMatches.length} matched face${topMatches.length !== 1 ? 's' : ''}...`);
        }

        function exportComparisonReport() {
            const resultsDiv = document.getElementById('results');
            
            if (!resultsDiv || resultsDiv.classList.contains('hidden')) {
                alert('Please run a comparison first!');
                return;
            }
            
            // Create a large canvas for the report
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate canvas size
            const refFace = referenceFaces[selectedReferenceIndex];
            const refBox = refFace.detection.box;
            const refCanvas = cropFaceFromImage(referenceImage, refBox, 40);
            
            const faceWidth = 300;
            const faceHeight = 300;
            const padding = 30;
            const headerHeight = 120;
            const labelHeight = 80;
            
            // Get top 5 matches
            const topMatches = [];
            comparisonImages.forEach((comp, imgIndex) => {
                comp.faces.forEach((face, faceIndex) => {
                    const referenceDescriptor = refFace.descriptor;
                    const distance = faceapi.euclideanDistance(referenceDescriptor, face.descriptor);
                    
                    let similarity;
                    if (distance < 0.4) {
                        similarity = 95 + (0.4 - distance) * 12.5;
                    } else if (distance < 0.5) {
                        similarity = 85 + (0.5 - distance) * 100;
                    } else if (distance < 0.6) {
                        similarity = 70 + (0.6 - distance) * 150;
                    } else if (distance < 0.7) {
                        similarity = 50 + (0.7 - distance) * 200;
                    } else {
                        similarity = Math.max(0, 50 - (distance - 0.7) * 100);
                    }
                    similarity = Math.min(100, Math.max(0, similarity));
                    
                    topMatches.push({ imgIndex, faceIndex, similarity, comp, face });
                });
            });
            
            topMatches.sort((a, b) => b.similarity - a.similarity);
            const displayMatches = topMatches.slice(0, 5);
            
            // Canvas dimensions
            const cols = Math.min(3, displayMatches.length + 1); // +1 for reference
            const rows = Math.ceil((displayMatches.length + 1) / cols);
            canvas.width = cols * (faceWidth + padding) + padding;
            canvas.height = headerHeight + rows * (faceHeight + labelHeight + padding) + padding;
            
            // Background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Header
            ctx.fillStyle = '#333333';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Face Comparison Report', canvas.width / 2, 60);
            
            let x = padding;
            let y = headerHeight + padding;
            
            // Draw reference face
            ctx.drawImage(refCanvas, 0, 0, refCanvas.width, refCanvas.height, x, y, faceWidth, faceHeight);
            
            // Label for reference
            ctx.fillStyle = '#4caf50';
            ctx.fillRect(x, y + faceHeight, faceWidth, labelHeight);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('REFERENCE', x + faceWidth / 2, y + faceHeight + 35);
            ctx.font = 'bold 20px Arial';
            if (refFace.age) {
                ctx.fillText(`Age: ~${Math.round(refFace.age)}`, x + faceWidth / 2, y + faceHeight + 62);
            }
            
            x += faceWidth + padding;
            
            // Draw matched faces
            displayMatches.forEach((match, index) => {
                if (index > 0 && index % cols === 0) {
                    x = padding;
                    y += faceHeight + labelHeight + padding;
                } else if (index === 1) {
                    x = padding;
                    y += faceHeight + labelHeight + padding;
                }
                
                const faceCanvas = cropFaceFromImage(match.comp.image, match.face.box, 40);
                ctx.drawImage(faceCanvas, 0, 0, faceCanvas.width, faceCanvas.height, x, y, faceWidth, faceHeight);
                
                // Label color based on match
                let labelColor;
                if (match.similarity >= 85) labelColor = '#4caf50';
                else if (match.similarity >= 70) labelColor = '#8bc34a';
                else if (match.similarity >= 50) labelColor = '#ffc107';
                else labelColor = '#f44336';
                
                ctx.fillStyle = labelColor;
                ctx.fillRect(x, y + faceHeight, faceWidth, labelHeight);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${match.similarity.toFixed(1)}% Match`, x + faceWidth / 2, y + faceHeight + 38);
                ctx.font = 'bold 18px Arial';
                if (match.face.age) {
                    ctx.fillText(`Age: ~${Math.round(match.face.age)}`, x + faceWidth / 2, y + faceHeight + 65);
                }
                
                x += faceWidth + padding;
            });
            
            // Download the report
            const timestamp = new Date().toISOString().slice(0, 10);
            downloadCanvas(canvas, `face_comparison_report_${timestamp}.png`);
        }

        function showError(element, message) {
            const error = document.createElement('div');
            error.className = 'error';
            error.textContent = message;
            element.appendChild(error);
        }

        // Initialize
        function initialize() {
            if (typeof faceapi === 'undefined') {
                console.log('Waiting for face-api.js to load...');
                setTimeout(initialize, 100);
                return;
            }
            
            // Check for saved dark mode preference, default to dark mode
            const savedDarkMode = localStorage.getItem('darkMode');
            if (savedDarkMode === null || savedDarkMode === 'true') {
                document.body.classList.add('dark-mode');
                if (savedDarkMode === null) {
                    localStorage.setItem('darkMode', 'true');
                }
            }
            
            console.log('Initializing face comparison tool...');
            setupEventListeners();
            loadModels();
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
    </script>
</body>
</html>
